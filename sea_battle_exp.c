// подключаем freeglut, чтобы могли разрабатывать
// графики и интерфейсы OpenGL
#include <GL/freeglut.h>
#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>
#include <time.h>
#include <string.h>
#include <memory.h>

/*
Определение размеров поля (GRID_SIZE)
и его ячеек (CELL_SIZE)
*/
#define GRID_SIZE 10
#define CELL_SIZE 50

/*
Установка ширины окна (WINDOW_WIDTH)
и высоты окна (WINDOW_HEIGHT)
*/
#define WINDOW_WIDTH 1200
#define WINDOW_HEIGHT 650

/*
Координаты смещения для отображения полей игрока и бота
(PLAYER/BOT_GRID_OFFSET)
*/
#define PLAYER_GRID_OFFSET_X 50
#define PLAYER_GRID_OFFSET_Y 50
#define BOT_GRID_OFFSET_X 650
#define BOT_GRID_OFFSET_Y 50

/*
Структура описывает состояние игры:
enum - Тип перечисления, который задаёт фиксированный набор
возможных значений.
У нас перечислены четыре состояния
1. MENU_SCREEN - игра в состоянии главного меню
2. PLACEMENT_SCREEN - фаза расстановки кораблей на поле
3. GAME_SCREEN - основной процесс игры - атака кораблей
4. GAME_OVER_SCREEN - финальный этап, игра завершена

использоваться будет в функции display(),
которая будет определять,
какую графическую сцену отрисовывать
*/
typedef enum {
    MENU_SCREEN,
    PLACEMENT_SCREEN,
    GAME_SCREEN,
    GAME_OVER_SCREEN
} GameState;

/*
Структура определяет свойства клетки,
где размещаются корабли и фиксируется процесс ведения игры

is_ship - указывает, присутствует ли корабль в ячейке
    true - в клетке часть корабля
    false - клетка пуста

is_hit - фиксирует попадание в ячейку
    true - выстрел попал в корабль
    false - выстрела не было или был промах

is_miss - отмечает клетку как часть поля,
куда уже был сделан выстрел, но никакого корабля там не было
*/
typedef struct {
    bool is_ship;
    bool is_hit;
    bool is_miss;
} Cell;

/*
Концепция типов кораблей и их количества
size - размер корабля (в количестве клеток)

count - количество кораблей ДАННОГО ТИПА

У нас в коде задан массивом

const ShipType shipTypes[] = {{4,1}, {3,2}, {2,3}, {1,4}};

он из четырёх типов кораблей
size 4, count 1
size 3, count 2
size 2, count 3
size 1, count 4
*/
typedef struct {
    int size;
    int count;
} ShipType;

/*
gameState - изначально игра запускается с главного меню

playerGrid - двумерный массив структур Cell
хранит состояние игрового поля игрока
botGrid - аналогична playerGrid, но для бота

horizontal - хранит информацию об ориентации корабля
при его расстановке horizontal - true
вертикальная - false
используется при повороте кораблей с помощью клавиши R
при их расстановке

playerTurn - указывает, чей сейчас ход
true - игрока
false - бота

gameOver - показывает, завершена ли игра или нет
в начале игры устанавливаем как false

showError - показывает наличие ошибки при попытке
выполнить некорректное действие (например, разместить
корабль в запрещённой ячейке)
*/
GameState gameState = MENU_SCREEN;
Cell playerGrid[GRID_SIZE][GRID_SIZE];
Cell botGrid[GRID_SIZE][GRID_SIZE];
bool horizontal = true;
bool playerTurn = true;
bool gameOver = false;
bool showError = false;

/*
массив констант типа ShipType, содержит информацию
о всех типах корабля
использоваться будет для управления процессами
расстановки кораблей для игрока и бота

currentShipType - индекс текущего корабля
из массива shipTypes (начинается с четырёхпалубного)

currentShipCount - текущее количество уже расположенных
кораблей конкретного типа
*/
const ShipType shipTypes[] = { {4,1}, {3,2}, {2,3}, {1,4} };
int currentShipType = 0;
int currentShipCount = 0;

/*
Объявляем простую пару координат (x,y)
Используется для хранения положений клеток (целей)
*/
typedef struct {
    int x;
    int y;
} Point;

/*
Создана для логики "умного" противника, который
анализирует попадания и использует стратегию для
дальнейших атак

hits[4] сохраняет координаты клеток, по которым бот успешно попал,
чтобы понять расположение корабля
максимально используется 4 точки в массиве, т.к
это длина самого крупного корабля

count - хранит текущее количество успешных попаданий
если бот попал дважды по одному и тому же кораблю,
count будет равно 2

direction - определяет направления для следующих выстрелов,
как только бот находит первую клетку корабля
возможных направлений 4 и они заданы числами:
    0 - вправо
    1 - влево
    2 - вниз
    3 - вверх

lastShot - координаты последнего произведённого выстрела
используется для анализа состояния и планирования
следующей атаки
*/
typedef struct {
    Point hits[4];
    int count;
    int direction;
    Point lastShot;
} BotAI;

/*
при начале игры зануляем все поля
координаты hits сброшены
количество попаданий count равно 0
направление стрельбы отсутствует
последний выстрел неизвестен
*/
BotAI botAI = { 0 };

/*
http://www.linuxfocus.org/Russian/January1998/article16.html
^
|
можно вставить в приложения

здесь мы определяем начальную инициализацию
графического окна игры
его параметры и привязку к функциям отрисовки и ввода

вообще, вагисарову лучше сказать,
что argc и argv в данном случае используются стандартно,
так как это требуется для работы GLUT.
Даже если аргументы явно не передаются, их наличие необходимо
для базовой инициализации графики

Это работает "на всякий случай",
даже если пользователь не передаёт параметры.

ну вот к примеру можно ввести -geometry WxH+X+Y
    это устанавливает размеры окна и его положение на экране
    -geometry 800x600+100+100

    тут 800x600 - размеры окна (ширина и высота)
    +100+100 - позиция окна относительно верхнего левого угла экрана

или
-display <дисплей> - задаёт дисплей, на котором
нужно отобразить окно
(ну это если больше чем 1 экран)
*/

// Прототипы всех функций
void display();
void handleKeyPress(unsigned char key, int x, int y);
void handleMouse(int button, int state, int x, int y);
void initializeGame();
void resetBotAI();
void startNewGame();
bool canPlaceShip(int x, int y, int size, bool horizontal, Cell grid[GRID_SIZE][GRID_SIZE]);
void placeShip(int x, int y);
void botPlaceShips();
void markDestroyedShip(Cell grid[GRID_SIZE][GRID_SIZE], int x, int y);
void checkDestroyedShips(Cell grid[GRID_SIZE][GRID_SIZE], int x, int y);
bool checkVictory(Cell grid[GRID_SIZE][GRID_SIZE]);
void botTurn();
void drawText(float x, float y, const char* text);
void drawGrid(int offsetX, int offsetY, bool showShips);
void drawShipCounts();
void drawPreviewShip();
void renderMenu();
void renderPlacement();
void renderGame();
void renderGameOver();
void findShipParts(Cell grid[GRID_SIZE][GRID_SIZE],
    int cx, int cy,
    bool visited[GRID_SIZE][GRID_SIZE],
    int shipCells[][2],
    int* count_ptr);


int main(int argc, char** argv) {
    /*
    glutInit инициализирует среду GLUT (или FreeGLUT)
    принимает параметры как раз из main(),
    по типу -geometry
    */
    glutInit(&argc, argv);
    /*
    устанавливает режим отображения
    изначально стоит GLUT_SINGLE (по умолчанию),
    но мы отменяем его, установив GLUT_DOUBLE

    GLUT_DOUBLE - двойная буферизация включается
    изображения рендерится отдельно в скрытом буфере,
    а затем отображается на экране (предотвращает визуальные
    (артефакты типо мигание)

    GLUT_RGB - указывает использование цветового пространства
    RGB, что соответствует стандарту цветового отображения
    */
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);

    /*
    устанавливает параметры начального размера окна
    ширина окна (1200 пикселей) и высота окна (650 пикселей)
    */
    glutInitWindowSize(WINDOW_WIDTH, WINDOW_HEIGHT);

    /*
    создаёт графическое окно для отображения игры
    заголовок окна будет "Sea Battle"
    */
    glutCreateWindow("Sea Battle");

    /*
    Указывает цвет фона окна в режиме RGBA

    0.9, 0.9, 0.9 - оттенки серого (почти белый фон)
    1.0 - полная непрозрачность (Alpha)
    */
    glClearColor(0.9f, 0.9f, 0.9f, 1.0f);

    /*
    Определяет 2D-координатное пространство для окна
    координаты 0.0 начинаются в верхнем левом углу
    а window_width и window_height определяют правый нижний угол
    */
    gluOrtho2D(0, WINDOW_WIDTH, WINDOW_HEIGHT, 0);

    // призывается функция void display() для отрисовки экрана
    // сама функция нужна для отрисовки кадра
    glutDisplayFunc(display);

    /*
    определяется функция для обработки действий пользователя
    при вводе с клавиатуры (handleKeyPress)
    ((к примеру кнопка R для поворота корабля))
    */
    glutKeyboardFunc(handleKeyPress);

    /*
    Включается обработка ввода мыши. Нужна для отслеживания:
        щелчки на игровом поле (выстрелы)
        выбор позиций для размещения кораблей
    */
    glutMouseFunc(handleMouse);

    /*
    устанавливаем начальное значение для генератоар случайных чисел

    использует текущее врея в секундах для большей случайности
    при вызове функции rand()

    применяется, чтобы расставить корабли бота случайно
    */
    srand(time(NULL));

    /*
    инициализируем игровые сетки для игрока и бота,
    сбрасываем параметры игры
    все клетки полей (playerGrid и botGrid) очищаются.
    у нас в коде:
        playerGrid[i][j] = (Cell){false, false, false};
        botGrid[i][j] = (Cell){false, false, false};
    также сбрасывается информация об ИИ бота через resetBotAI;
    */
    initializeGame();

    // запускает главный цикл обработки сообщений
    /*
    в этом режиме программа постоянно
        перерисовывает окно при необходимости (вызов display)
        обрабатывает действия пользователя (нажатия клавиш и мыши)
        держит приложение "живым", пока пользователь явно его не закроет
    */
    glutMainLoop();
    return 0;
}

/*
эта функция готовит игровую сетку пользователя и бота к началу игры,
очищая данные о кораблях, попаданиях и промахах
также сбрасывает состояние логики бота
*/
void initializeGame() {
    // цикл проходит по каждому ряду (i) игрового поля (размеры заданы GRID_SIZE)
    for (int i = 0; i < GRID_SIZE; i++) {
        // цикл проходит по каждой колонке (j) игрового поля
        for (int j = 0; j < GRID_SIZE; j++) {
            // каждая клетка обеих сеток инициализируется как пустая
            /*
            is_ship, is_hit и is_miss устанавливаются как false
            т.к нет корабля, не было попадания и промаха
            */
            playerGrid[i][j] = (Cell){ false, false, false };
            botGrid[i][j] = (Cell){ false, false, false };
        }
    }
    /*
    после очистки сеток вызывается функция сброса настроек бота
    */
    resetBotAI();
}

/*
полностью сбрасывает логику искусственного интеллекта бота, чтобы он
"забыл" предыдущие попадания и направления атак
memset заполняет всю память структуры BotAI нулями
все поля структуры становятся равными 0 (hits, count, direction, lastShot)
это гарантирует, что логика бота начнёт работу как с чистого листа
*/
void resetBotAI() {
    memset(&botAI, 0, sizeof(BotAI));
}


/*
инициализирует новую игру,
полный сброс состояния игры
*/
void startNewGame() {
    // сбрасывает сетки полей и состояние бота
    initializeGame();
    // игра переходит в режим расстановки кораблей
    gameState = PLACEMENT_SCREEN;
    // индекс текущего корабля и число его размещений сбрасываются
    currentShipType = 0;
    currentShipCount = 0;

    // определяет, что пользователь делает первый ход
    playerTurn = true;
    // игра не завершена
    gameOver = false;
    // скрывается любое сообщение об ошибках ввода
    // ошибка вылезет, если человек неправильно поставит корабль
    showError = false;
    // начальная ориентация кораблей горизонтальная
    horizontal = true;

    // вызываем функцию для размещения всех кораблей бота
    botPlaceShips();

    // сообщает библиотеке GLUT, что
    // окно следует перерисовать с учётом новых данных
    glutPostRedisplay();
}

/*
проверяет, можно ли разместить корабль в определённой точке на поле игрока
*/
bool canPlaceShip(int x, int y, int size, bool horizontal, Cell grid[GRID_SIZE][GRID_SIZE]) {

    /*
    проверка на границы

    1. x < 0 || y < 0 - если начальная координата отрицательная,
    это значит, что корабль выходит за пределы левой
    или верхней границы игрового поля

    2. horizontal && x + size > GRID_SIZE - если корабль
    размещается горизонтально и его длина пересекает правую границу сетки,
    то размещение недопустимо

    3.  !horizontal && y + size > GRID_SIZE - если корабль располагается вертикально
    и его длина пересекает нижнюю границу сетки, то размещение недопустимо

    если одно из вышеуказанных условий выполняется, то функция завершает работу
    и результат false.

    */
    if (x < 0 || y < 0 || (horizontal && x + size > GRID_SIZE) || (!horizontal && y + size > GRID_SIZE))
        return false;

    /*
    первый цикл по x проходит на одну клетку левее корабля (x-1)
    и на одну клетку правее (x + size для горизонтального корабля
    или x + 1 для вертикального)

    второй цикл по y проходит на одну клетку выше (y-1) и на одну клетку ниже
    (y + size для вертикального корабля или y + 1 для горизонтального)
    */
    for (int i = x - 1; i <= x + (horizontal ? size : 1); i++) {
        for (int j = y - 1; j <= y + (horizontal ? 1 : size); j++) {

            /*
            условия в проверке
            i >= 0 && i < GRID_SIZE = убедиться, что проверяемая координата x
            находится в пределах игрового поля

            j >= 0 && j < GRID_SIZE = то же, что и выше, но для координаты y

            grid[i][j].is_ship проверяет наличие корабля в указанной ячейке grid.
            если в клетке уже есть часть корабля, значит размещение недопустимо

            по факту оно возвращает false, если хотя бы одна из проверяемых клеток
            вокруг корабля занята (включая соседние зоны)
            */
            if (i >= 0 && i < GRID_SIZE && j >= 0 && j < GRID_SIZE && grid[i][j].is_ship)
                return false;
        }
    }

    // если ни одно из условий не срабатывает,
    // значит можно поставить true (корабль можно ставить)
    return true;
}

/*
отвечает за размещение кораблей на поле игрока (playerGrid)
и делает следующее:
    1. проверяет, может ли корабль быть размещён
    2. устанавливает клетки для размещённого корабля
    3. обновляет статус текущего типа корабля
    4. переводит игру в стадию, где начнутся выстрелы (GAME_SCREEN)
    после завершения расстановки всех кораблей
*/
void placeShip(int x, int y) {

    /*
    проверка индекса текущего корабля
    currentShipType - индекс, текущего типа корабля в массиве shipTypes
    (например, четырёхпалубный, однопалубный)

    sizeof(shipTypes)/sizeof(shipTypes[0])
    вычисляет общее количество типов кораблей в массиве

    если все типы кораблей уже размещены, то функция завершается
    */
    if (currentShipType >= sizeof(shipTypes) / sizeof(shipTypes[0])) {
        return;
    }

    // извлекается размер текущего размещаемого корабля
    /*
    (4 - четырёхпалубный, 1 - однопалубный и т.д)
    */
    int size = shipTypes[currentShipType].size;

    /*
    проверка доступности размещения
    вызывается функция чтобы проверить:
        входит ли корабль в границы поля
        не пересекается ли он с другими кораблями или их зонами

        если размещение невозможно
            устанавливается флаг ошибки (showError = true)
            выполняется перерисовка экрана с выводом ошибки (glutPostRedisplay)
            завершается выполнение функции
    */
    if (!canPlaceShip(x, y, size, horizontal, playerGrid)) {
        showError = true;
        glutPostRedisplay();
        return;
    }

    // если корабль можно разместить, то сбрасываем флаг ошибок
    showError = false;

    /*
    размещение корабля

    цикл выполняется size раз - по количеству клеток, занимаемых кораблём
    для четырёхпалубного выполнится 4 раза, чтобы проставить каждую клетку корабля
    */
    for (int i = 0; i < size; i++) {
        /*
        если корабль расположен горизонтально (horizontal = true)
            nx будет меняться (от x до x + size - 1)
                x + size - 1 нужно, чтобы вычислить последнюю координату x
                клетки, которую занимает корабль, размещённый горизонтально
                для вертикального размещения аналогично y + size - 1

                -1 же потому что длина корабля в клетках включает НАЧАЛЬНУЮ клетку
                и все последующие до конца корабли
            ny будет фиксированным на уровне строки (y)

        если вертикально (horizontal = false)
            nx фиксирован - корабль остаётся в одной колонке (x)
            ny изменяется (от y до y + size - 1)
        */
        int nx = horizontal ? x + i : x;
        int ny = horizontal ? y : y + i;

        /*
        для кадой клетки с вычисленными координатами nx и ny устанавливается
        флаг, указывающий, что здесь находится часть корабля
        */
        playerGrid[nx][ny].is_ship = true;
    }

    // увеличивает счётчик кораблей текущего типа, которые уже размещены
    currentShipCount++;

    /*
    проверяет, размещены ли все корабли текущего типа
        если да:
            счётчик текущего типа (currentShipType) увеличивается,
            чтобы перейти к следующему кораблю
    */
    if (currentShipCount >= shipTypes[currentShipType].count) {
        currentShipType++;
        // сбрасывает счётчик размещений для нового типа кораблей
        currentShipCount = 0;
    }

    // завершение этапа расстановки

    /*
    вычисляет общее количество типов кораблей (размер массива
    shipTypes делится на размер одного элемента)
    если размещены все корабли
    */
    if (currentShipType >= sizeof(shipTypes) / sizeof(shipTypes[0])) {
        // игра переходит из стадии расстановки (PLACEMENT_SCREEN)
        // в стадию стрельбы (GAME_SCREEN)
        gameState = GAME_SCREEN;
    }

    /*
    указывает библиотеке FreeGLUT на необходимость обновления графического окна
    в результате мы видим размещённые корабли или сообщения об ошибках в граф. интерфейсе
    */
    glutPostRedisplay();
}

/*
Расставляет корабли на поле бота (botGrid) случайным образом,
соблюдая правила игры:
    1. учитывается размер кораблей и их количество
    2. проверяет корректность размещения (пересечения и выход за границы)
    3. ограничивается количество попыток размещения (максимум 100)
*/
void botPlaceShips() {
    /*
    цикл по типам кораблей:
        sizeof(shipTypes)/sizeof(shipTypes[0] вычисляет кол. типов кораблей
        цикл проходит по каждому типу корабля - линкор (4п), крейсер (3п),
        эсминец (2п) и подлодка (1п)
    */
    for (int type = 0; type < sizeof(shipTypes) / sizeof(shipTypes[0]); type++) {
        /*
        цикл по количеству кораблей данного типа
            указывает, сколько кораблей каждого типа нужно разместить
            для подлодок (count = 4) этот цикл выполнится 4 раза
        */
        for (int ship = 0; ship < shipTypes[type].count; ship++) {

            /*
            подготовка размещения
                placed - флаг, показывающий, успешно ли размещён корабль
                attempts - счётчик попыток
                    предотвращает бесконечный цикл в редких случаях
                    (макс. 100 попыток для каждого корабля)
            */
            bool placed = false;
            int attempts = 0;

            /*
            цикл выполняется, пока корабль не будет размещён корректно
            или пока число попыток не достигнет 100
            */
            while (!placed && attempts < 100) {
                /*
                случайное определение координат и ориентации

                int x = rand() % GRID_SIZE; генерирует случайную координату по оси X
                диапазон значений  0 ≤x<GRID_SIZE

                rand() берёт псевдослучайное целое число

                %GRID_SIZE ограничивает значение диапазоном от 0 до GRID_SIZE - 1

                к примеру
                    поле размером 10x10, rand выдаёт 42, после % - результат: 2
                или
                    rand() = 17 -> результат: 7 (позиция в пределах поля)

                    для y ровно то же самое

                */
                int x = rand() % GRID_SIZE;
                int y = rand() % GRID_SIZE;

                /*
                генерирует случайный булевый результат для ориентации
                    rand() % 2 генерирует либо 0 (горизонтально)
                    либо 1 (вертикально)
                    == 0 интерпретирует это как
                        true -> горизонтальный корабль
                        false -> вертикальный корабль
                */
                bool dir = rand() % 2 == 0;

                /*
                проверка возможности размещения
                    функция проверяет, можно ли разместить корабль в этом месте
                    нет ли пересечений с другими кораблями
                    не выходит ли корабль за границы поля
                */
                if (canPlaceShip(x, y, shipTypes[type].size, dir, botGrid)) {
                    /*
                    успешное размещение

                    если проверка прошла успешно, то корабль размещается:
                    */
                    for (int i = 0; i < shipTypes[type].size; i++) {
                        /*
                        dir = true = горизонтальное размещение
                            координата nx меняется (x, x + 1, x + 2 и т.д)
                            координата ny не меняется
                        dir = false = вертикальное размещение
                            координата nx не меняется
                            координата ny меняется (y, y + 1, y + 2 и т.д)
                        */
                        int nx = dir ? x + i : x;
                        int ny = dir ? y : y + i;

                        // клетки, занятые кораблём, помечаются с флагом is_ship = true
                        botGrid[nx][ny].is_ship = true;
                    }

                    // если корабль успешно размещён, то флаг становится true,
                    // что завершает цикл while
                    placed = true;
                }
                // переходит к следующей попытке размещения, если надо
                attempts++;
            }
        }
    }
}

/*
функция помечает уничтоженный корабль
и все клетки вокруг него как "промахи" (is_miss),
чтобы
    показать игроку, что корабль полностью потоплен
    запретить стрелять в клетки вокруг корабля

она рекурсивно ищет все клетки корабля,
начиная с заданной точки (x,y)

помечает каждую клетку корабля как is_miss
(чтобы отобразить его как уничтоженный)

помечает все соседние клетки
(включая диагонали) как is_hit и is_miss,
чтобы в них больше нельзя было стрелять
*/
void markDestroyedShip(Cell grid[GRID_SIZE][GRID_SIZE], int x, int y) {
    // если клетка уже помечена как is_miss
    // (значит, корабль уже отмечен как уничтоженный)
    // то функция завершается
    if (grid[x][y].is_miss) return;

    // подготовка данных для поиска корабля

    /*
    создаём матрицу visited (10x10), заполненную false
    чтобы при рекурсивном поиске не зациклиться
    на уже проверенных клетках
    */
    bool visited[GRID_SIZE][GRID_SIZE] = { false };

    /*
    хранит координаты всех клеток корабля
    размер 100x2 (макс. возможный корабль - 4 клетки,
    но для перестраховки резервируется 100)

    это чтобы не вычислять точный размер корабля заранее

    МОЖНО БЫЛО БЫ И 4, но я выбрал простоту над оптимизацией
    */
    int shipCells[GRID_SIZE * GRID_SIZE][2];

    // счётчик найденных клеток корабля (изначально 0)
    int count = 0;

    // запускает рекурсивный поиск, начиная с (x,y)
    findShipParts(grid, x, y, visited, shipCells, &count);

    // помечаем клетку корабля как (is_miss) уничтоженную

    // цикл проходит по всем найденным клеткам корабля
    for (int i = 0; i < count; i++) {
        // помечает клетку корабля как уничтоженную (is_miss)
        grid[shipCells[i][0]][shipCells[i][1]].is_miss = true;

        /*
        двойной цикл для проверки всех 8 соседей
        (включая диагонали)

        di (delta i) - смещение по горизонтали (X-координата)

        dj (delta j) - смещение по вертикали (Y-координата)

        пример,
        допустим, клетка имеет координаты (4,5)
            сосед слева (di = -1, dj = 0)
                n1 = 4 + (-1) = 3
                nj = 5 + 0 = 5
            -> координаты соседа: (3, 5)
            сосед сверху-справа (di = +1, dj = +1)
                ni = 4 + 1 = 5
                nj = 5 + 1 = 6
            -> координаты соседа: (5, 6)
        */
        for (int di = -1; di <= 1; di++) {
            for (int dj = -1; dj <= 1; dj++) {
                /*
                вычисляет координаты соседа (ni, nj)

                кстати в цикле if
                !grid[ni][nj].is_hit не даст пометить клетку корабля,
                т.к она уже is_hit = true

                ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE
                проверяет границы поля
                отсекает соседей за пределами поля
                (например, для клетки 0,0) сосед (-1, -1) недопустим

                !grid[ni][nj].is_hit
                если в соседа уже стреляли,
                то он не помечается повторно

                тем самым проверяются все 8 направлений,
                включая диагонали
                работает для кораблей любого размера (1-4 клетки)
                */
                int ni = shipCells[i][0] + di;
                int nj = shipCells[i][1] + dj;
                if (ni >= 0 && ni < GRID_SIZE && nj >= 0 && nj < GRID_SIZE && !grid[ni][nj].is_hit) {
                    // "сюда стреляли"
                    // фиксирует факт выстрела
                    grid[ni][nj].is_hit = true;
                    // "здесь нет корабля"
                    grid[ni][nj].is_miss = true;
                }
                /*
                на будущее:
                    для подбитых палуб корабля
                    используется только is_miss = true
                    (без дополнительных проверок)
                    (корабль здесь уничтожен)

                    для соседей - is_hit и is_miss,
                    чтобы заблокировать их
                    для выстрелво и показать их пустоту
                    (сюда стреляли и здесь пусто)
                */
            }
        }
    }
}

/*
проверяет, полностью ли уничтожен корабль
после попадания в клетку (x, y).
если да, то вызывает markDestroyedShip,
чтобы пометить корабль и соседей как "уничтоженные"

она проверяет, является ли клетка (x,y) частью корабля

рекурсивно ищет все клетки этого корабля (аналогично
markDestroyedShip)

проверяет, все ли клетки корабля подбиты (is_hit = true)

если да, то помечает корабль как уничтоженный через
markDestroyedShip
*/
void checkDestroyedShips(Cell grid[GRID_SIZE][GRID_SIZE], int x, int y) {
    //если в клетке нет корабля, функция завершается
    // (попадания не было)
    if (!grid[x][y].is_ship) return;

    // фиксирует попадание в клетку (x, y)
    grid[x][y].is_hit = true;

    // матрица посещённых клеток
    bool visited[GRID_SIZE][GRID_SIZE] = { false };
    // координаты всех клеток корабля
    // взяли с запасом сотку,
    // чтобы не вычислять точный размер корабля заранее
    int shipCells[GRID_SIZE * GRID_SIZE][2];
    int count = 0;

    findShipParts(grid, x, y, visited, shipCells, &count);

    /*
    проверка, уничтожен ли корабль

    allHit = true - изначально предполагаем, что корабль уничтожен

    цикл проверяет все клетки корабля
        если хоть одна не подбита (!is_hit)
            то allHit = false
    */
    bool allHit = true;
    for (int i = 0; i < count; i++) {
        if (!grid[shipCells[i][0]][shipCells[i][1]].is_hit) {
            allHit = false;
            break;
        }
    }

    // если корабль уничтожен, то помечаем его
    if (allHit) {
        markDestroyedShip(grid, x, y);
    }
}


/*
Функция checkVictory используется для проверки победы в игре.
Она определяет, остались ли у игрока или компьютера корабли, которые ещё не подбиты.
Функция возвращает true, если все корабли на данном игровом поле были подбиты, иначе возвращает false.
*/
bool checkVictory(Cell grid[GRID_SIZE][GRID_SIZE]) {
    // Основной цикл: итерация по строкам игрового поля.
    for (int i = 0; i < GRID_SIZE; i++) {
        // Вложенный цикл: итерация по столбцам текущей строки.
        for (int j = 0; j < GRID_SIZE; j++) {
            /*
            Условие проверки:
            Если в ячейке grid[i][j] находится часть корабля (is_ship == true),
            но по ней ещё не попали (is_hit == false),
            то игра не завершена, функция возвращает false.
            */
            if (grid[i][j].is_ship && !grid[i][j].is_hit) {
                return false;
            }
        }
    }
    // Если все клетки с кораблями были подбиты, возвращаем true (победа).
    return true;
}




/*
Функция botTurn отвечает за ход компьютера (бота) в игре.
Бот анализирует текущее состояние поля игрока, использует базовые стратегии для проведения атаки,
и проверяет условия завершения игры. Если ещё не найдено место выстрела (или нет информации о попадании),
бот делает случайный ход. После каждого действия производятся проверки состояния игры и обновляется интерфейс.
*/
void botTurn() {
    // Проверка на завершение игры (если gameOver == true, бот больше не должен ходить).
    if (gameOver) return;

    // Параметры для запоминания координат следующего выстрела.
    int x = -1, y = -1;
    bool targetFound = false;  // Определяет, удалось ли найти цель для атаки.
    bool shipDestroyed = false; // Флаг: корабль уничтожен.
    int attempts = 0; // Число попыток случайного выстрела.

    /*
    Проверка информации от логики искусственного интеллекта бота (botAI):
    Если есть частично уничтоженный корабль (botAI.count > 0),
    продолжаем стрелять по соседним клеткам в поиске оставшихся частей корабля.
    */
    if (botAI.count > 0) {
        const int dirs[4][2] = { {1,0}, {-1,0}, {0,1}, {0,-1} };  // Возможные направления (вправо, влево, вниз, вверх).

        for (int i = 0; i < botAI.count && !targetFound; i++) {
            for (int j = 0; j < 4 && !targetFound; j++) {
                x = botAI.hits[i].x + dirs[j][0]; // Вычисляем соседнюю клетку по X.
                y = botAI.hits[i].y + dirs[j][1]; // Вычисляем соседнюю клетку по Y.

                /*
                Проверяем, не выходят ли координаты x и y за пределы поля
                И в данную клетку ещё не стреляли (!playerGrid[x][y].is_hit).
                */
                if (x >= 0 && x < GRID_SIZE && y >= 0 && y < GRID_SIZE && !playerGrid[x][y].is_hit) {
                    targetFound = true;
                }
            }
        }

        // Если не удалось найти направление атаки, помечаем корабль как уничтоженный.
        if (!targetFound) {
            markDestroyedShip(playerGrid, botAI.hits[0].x, botAI.hits[0].y);
            resetBotAI(); // Сбрасываем логику ИИ бота для новой стратегии.
            shipDestroyed = true;
        }
    }

    // Если цели не найдено или корабль уничтожен, выполняется случайный выстрел.
    if (!targetFound && !shipDestroyed) {
        do {
            x = rand() % GRID_SIZE;  // Генерация случайной координаты по X.
            y = rand() % GRID_SIZE;  // Генерация случайной координаты по Y.
            attempts++;
        } while (playerGrid[x][y].is_hit && attempts < 200);  // Постараемся не стрелять повторно в одну и ту же клетку.
    }

    /*
    Проверяем, что выстрел не относится к уничтоженному кораблю (shipDestroyed == false).
    Если корабль подбит:
      - Добавляем его координаты в список попаданий (botAI.hits).
      - Проверяем, полностью ли уничтожен корабль.
    Если выстрел не попал, передаём ход игроку.
    */
    if (!shipDestroyed) {
        playerGrid[x][y].is_hit = true;  // Помечаем клетку как атакованную.

        if (playerGrid[x][y].is_ship) {
            if (botAI.count < 4) {
                botAI.hits[botAI.count].x = x;  // Запоминаем координату X попадания.
                botAI.hits[botAI.count].y = y;  // Запоминаем координату Y попадания.
                botAI.count++;
            }

            checkDestroyedShips(playerGrid, x, y); // Проверяем статус повреждённого корабля.

            if (playerGrid[x][y].is_miss) {
                shipDestroyed = true; // Если корабль уничтожен, сбрасываем логику AI.
                resetBotAI();
            }

        }
        else {
            playerTurn = true;  // Если промах, передаём ход игроку.
        }
    }

    // Проверяем, не уничтожил ли бот все корабли игрока (победа бота).
    if (checkVictory(playerGrid)) {
        gameOver = true;  // Завершаем игру.
        gameState = GAME_OVER_SCREEN;  // Переход к финальному экрану.
    }

    // Обновляем отображение интерфейса.
    glutPostRedisplay();

    /*
    Если ход всё ещё за ботом (playerTurn == false), планируем следующий выстрел
    через короткую паузу (glutTimerFunc задерживает вызов botTurn на 1000 мс).
    */
    if (!playerTurn && !gameOver) {
        glutTimerFunc(1000, (void (*)(int))botTurn, 0);
    }
}




/*
Функция drawText отвечает за отрисовку текста на экране.
Используя OpenGL функцию glRasterPos2f, она устанавливает начальные координаты текста,
а затем выводит каждый символ строки, используя шрифт GLUT_BITMAP_HELVETICA_18.
*/
void drawText(float x, float y, const char* text) {
    // Устанавливаем позицию текста с помощью glRasterPos2f.
    glRasterPos2f(x, y);

    // Цикл проходит по каждому символу строки.
    for (const char* c = text; *c != '\0'; c++) {
        // Отрисовываем текущий символ с использованием GLUT шрифта.
        glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, *c);
    }
}

/*
Функция drawGrid отвечает за отрисовку игрового поля (сетки).
Она отображает сетку с осями X и Y, её клетки и их текущее состояние (корабль, попадание, промах).
Также функция может отображать корабли игрока (если showShips == true).
*/
void drawGrid(int offsetX, int offsetY, bool showShips) {
    // Выбираем игровую сетку (playerGrid для игрока, botGrid для противника).
    Cell(*grid)[GRID_SIZE] = showShips ? playerGrid : botGrid;

    // Цикл проходит по строкам сетки.
    for (int i = 0; i < GRID_SIZE; i++) {
        // Цикл проходит по столбцам сетки.
        for (int j = 0; j < GRID_SIZE; j++) {
            // Вычисляем реальные экранные координаты текущей клетки (левый верхний угол).
            float x = offsetX + i * CELL_SIZE;
            float y = offsetY + j * CELL_SIZE;

            // Логика выбора цвета в зависимости от состояния клетки.
            if (grid[i][j].is_miss && grid[i][j].is_ship) {
                glColor3f(1.0, 0.0, 0.0);  // Красный (корабль уничтожен).
            }
            else if (grid[i][j].is_hit && grid[i][j].is_ship) {
                glColor3f(1.0, 0.5, 0.0);  // Оранжевый (корабль подбит).
            }
            else if (grid[i][j].is_hit) {
                glColor3f(0.8, 0.8, 0.8);  // Серый (промах).
            }
            else if (showShips && grid[i][j].is_ship) {
                glColor3f(0.3, 0.3, 0.3);  // Тёмно-серый (корабль игрока).
            }
            else {
                glColor3f(0.8, 0.8, 1.0);  // Светло-синий (пустая клетка).
            }

            // Отрисовка заполненного квадрата клетки.
            glBegin(GL_QUADS);
            glVertex2f(x, y);
            glVertex2f(x + CELL_SIZE, y);
            glVertex2f(x + CELL_SIZE, y + CELL_SIZE);
            glVertex2f(x, y + CELL_SIZE);
            glEnd();

            // Отрисовка "границ" каждого квадрата (контур).
            glColor3f(0.5, 0.5, 0.5);  // Средне-серый для границ.
            glBegin(GL_LINE_LOOP);
            glVertex2f(x, y);
            glVertex2f(x + CELL_SIZE, y);
            glVertex2f(x + CELL_SIZE, y + CELL_SIZE);
            glVertex2f(x, y + CELL_SIZE);
            glEnd();
        }
    }

    // Устанавливаем чёрный цвет для текста координат.
    glColor3f(0.0, 0.0, 0.0);

    // Добавляем буквы (A-J) по оси X над сеткой.
    for (int i = 0; i < GRID_SIZE; i++) {
        char letter[2] = { 'A' + i, '\0' }; // Преобразуем индекс i в букву.
        drawText(offsetX + i * CELL_SIZE + CELL_SIZE / 2 - 5, offsetY - 25, letter);
    }

    // Добавляем цифры (1-10) по оси Y слева от сетки.
    for (int i = 0; i < GRID_SIZE; i++) {
        char number[3];
        snprintf(number, sizeof(number), "%d", i + 1);
        drawText(offsetX - 25, offsetY + i * CELL_SIZE + CELL_SIZE / 2 - 5, number);
    }
}


/*
Функция drawShipCounts отображает количество оставшихся кораблей для игрока и противника.
Она использует нерекурсивный обход для проверки целых кораблей и учитывает только полностью уничтоженные корабли.
*/
void drawShipCounts() {
    char text[50]; // Буфер для формирования текстовых строк
    glColor3f(0.0, 0.0, 0.0); // Установка черного цвета текста

    // Инициализация счетчиков кораблей
    // Начинаем с максимального количества каждого типа кораблей
    int playerShips[4] = { shipTypes[0].count, shipTypes[1].count, shipTypes[2].count, shipTypes[3].count };
    int botShips[4] = { shipTypes[0].count, shipTypes[1].count, shipTypes[2].count, shipTypes[3].count };

    // Подсчет уничтоженных кораблей бота
    bool botProcessed[GRID_SIZE][GRID_SIZE] = { false }; // Матрица для отслеживания обработанных клеток
    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            // Если нашли подбитую палубу, которую еще не обрабатывали
            if (botGrid[i][j].is_ship && botGrid[i][j].is_miss && !botProcessed[i][j]) {
                bool visited[GRID_SIZE][GRID_SIZE] = { false }; // Матрица посещений для текущего корабля
                int shipSize = 0; // Размер текущего корабля
                bool fullyDestroyed = true; // Флаг полного уничтожения корабля

                // Нерекурсивный обход корабля с использованием стека
                int stack[GRID_SIZE * GRID_SIZE][2]; // Стек для координат клеток
                int stackSize = 0; // Текущий размер стека
                stack[stackSize][0] = i; // Добавляем начальную клетку в стек
                stack[stackSize][1] = j;
                stackSize++;

                while (stackSize > 0) {
                    // Извлекаем координаты из стека
                    stackSize--;
                    int x = stack[stackSize][0];
                    int y = stack[stackSize][1];

                    // Пропускаем клетки за границами, уже посещенные или не являющиеся кораблем
                    if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE ||
                        visited[x][y] || !botGrid[x][y].is_ship) {
                        continue;
                    }

                    visited[x][y] = true; // Помечаем клетку как посещенную
                    botProcessed[x][y] = true; // Помечаем клетку как обработанную
                    shipSize++; // Увеличиваем размер корабля

                    // Если хоть одна палуба не подбита - корабль не уничтожен полностью
                    if (!botGrid[x][y].is_miss) {
                        fullyDestroyed = false;
                    }

                    // Добавляем всех четырех соседей в стек для дальнейшего обхода
                    stack[stackSize][0] = x + 1; stack[stackSize][1] = y; stackSize++;
                    stack[stackSize][0] = x - 1; stack[stackSize][1] = y; stackSize++;
                    stack[stackSize][0] = x; stack[stackSize][1] = y + 1; stackSize++;
                    stack[stackSize][0] = x; stack[stackSize][1] = y - 1; stackSize++;
                }

                // Если корабль полностью уничтожен, уменьшаем соответствующий счетчик
                if (fullyDestroyed) {
                    for (int t = 0; t < 4; t++) {
                        if (shipTypes[t].size == shipSize && botShips[t] > 0) {
                            botShips[t]--;
                            break;
                        }
                    }
                }
            }
        }
    }

    // Аналогичный подсчет для игрока (та же логика, но для поля игрока)
    bool playerProcessed[GRID_SIZE][GRID_SIZE] = { false };
    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            if (playerGrid[i][j].is_ship && playerGrid[i][j].is_miss && !playerProcessed[i][j]) {
                bool visited[GRID_SIZE][GRID_SIZE] = { false };
                int shipSize = 0;
                bool fullyDestroyed = true;

                int stack[GRID_SIZE * GRID_SIZE][2];
                int stackSize = 0;
                stack[stackSize][0] = i;
                stack[stackSize][1] = j;
                stackSize++;

                while (stackSize > 0) {
                    stackSize--;
                    int x = stack[stackSize][0];
                    int y = stack[stackSize][1];

                    if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE ||
                        visited[x][y] || !playerGrid[x][y].is_ship) {
                        continue;
                    }

                    visited[x][y] = true;
                    playerProcessed[x][y] = true;
                    shipSize++;

                    if (!playerGrid[x][y].is_miss) {
                        fullyDestroyed = false;
                    }

                    stack[stackSize][0] = x + 1; stack[stackSize][1] = y; stackSize++;
                    stack[stackSize][0] = x - 1; stack[stackSize][1] = y; stackSize++;
                    stack[stackSize][0] = x; stack[stackSize][1] = y + 1; stackSize++;
                    stack[stackSize][0] = x; stack[stackSize][1] = y - 1; stackSize++;
                }

                if (fullyDestroyed) {
                    for (int t = 0; t < 4; t++) {
                        if (shipTypes[t].size == shipSize && playerShips[t] > 0) {
                            playerShips[t]--;
                            break;
                        }
                    }
                }
            }
        }
    }

    // Формирование и вывод строки с количеством оставшихся кораблей игрока
    snprintf(text, sizeof(text), "Your ships: 4(%d) 3(%d) 2(%d) 1(%d)",
        playerShips[0], playerShips[1], playerShips[2], playerShips[3]);
    drawText(PLAYER_GRID_OFFSET_X, PLAYER_GRID_OFFSET_Y + GRID_SIZE * CELL_SIZE + 20, text);

    // Формирование и вывод строки с количеством оставшихся кораблей противника
    snprintf(text, sizeof(text), "Enemy ships: 4(%d) 3(%d) 2(%d) 1(%d)",
        botShips[0], botShips[1], botShips[2], botShips[3]);
    drawText(BOT_GRID_OFFSET_X, BOT_GRID_OFFSET_Y + GRID_SIZE * CELL_SIZE + 20, text);
}


/*
Функция drawPreviewShip отображает предварительный просмотр текущего корабля,
который игрок пытается разместить. Работает только в фазе PLACEMENT_SCREEN.
*/
void drawPreviewShip() {
    // Проверяем, активна ли фаза размещения кораблей.
    if (gameState != PLACEMENT_SCREEN || currentShipType >= 4) return;

    // Получаем размер текущего корабля.
    int size = shipTypes[currentShipType].size;

    // Устанавливаем полупрозрачный зелёный цвет для показа корабля.
    glColor4f(0.0, 1.0, 0.0, 0.5);

    // Начинаем прорисовку квадратиков для корабля.
    glBegin(GL_QUADS);
    for (int i = 0; i < size; i++) {
        // Вычисляем реальные экранные координаты каждого квадрата.
        float x = PLAYER_GRID_OFFSET_X + GRID_SIZE * CELL_SIZE + 20 + (horizontal ? i : 0) * CELL_SIZE;
        float y = 160 + (horizontal ? 0 : i) * CELL_SIZE;

        // Рисуем текущий квадрат корабля (одна клетка).
        glVertex2f(x, y);
        glVertex2f(x + CELL_SIZE, y);
        glVertex2f(x + CELL_SIZE, y + CELL_SIZE);
        glVertex2f(x, y + CELL_SIZE);
    }
    glEnd();

    char info[50]; // Текстовая метка для показа текущего корабля.

    // Отображаем текст о размере (палубы) корабля.
    snprintf(info, sizeof(info), "Ship: %d-decker", size);
    drawText(PLAYER_GRID_OFFSET_X + GRID_SIZE * CELL_SIZE + 20, 130, info);

    // Показываем, сколько таких кораблей осталось.
    snprintf(info, sizeof(info), "Left: %d", shipTypes[currentShipType].count - currentShipCount);
    drawText(PLAYER_GRID_OFFSET_X + GRID_SIZE * CELL_SIZE + 20, 100, info);
}

/*
Функция renderMenu отвечает за отрисовку главного меню игры.
Она показывает заголовок игры, инструкции по управлению и как начать.
*/
void renderMenu() {
    // Очищаем экран от предыдущего содержания.
    glClear(GL_COLOR_BUFFER_BIT);

    // Заголовок "SEA BATTLE" с использованием синего цвета.
    glColor3f(0.1, 0.1, 0.5);
    drawText(WINDOW_WIDTH / 2 - 100, WINDOW_HEIGHT / 2 - 50, "SEA BATTLE");

    // Чёрный цвет для инструкций.
    glColor3f(0.0, 0.0, 0.0);
    drawText(WINDOW_WIDTH / 2 - 120, WINDOW_HEIGHT / 2 + 50, "Press any key to start");
    drawText(WINDOW_WIDTH / 2 - 200, WINDOW_HEIGHT / 2 + 80, "Controls: R - Rotate, N - New game, Q - Quit");
    drawText(WINDOW_WIDTH / 2 - 180, WINDOW_HEIGHT / 2 + 110, "Placement: LMB - Place ship");
    drawText(WINDOW_WIDTH / 2 - 180, WINDOW_HEIGHT / 2 + 140, "Game: LMB - Shoot at enemy field");

    // Выводим обновлённое меню на экран.
    glutSwapBuffers();
}

/*
Функция renderPlacement отрисовывает текущую фазу расстановки кораблей для игрока.
Она показывает поле игрока, предпросмотр текущего корабля и возможные ошибки размещения.
*/
void renderPlacement() {
    // Очищаем экран перед обновлением.
    glClear(GL_COLOR_BUFFER_BIT);

    // Заголовок "Your field" над полем игрока.
    drawText(PLAYER_GRID_OFFSET_X + (GRID_SIZE * CELL_SIZE) / 2 - 50, 50, "Your field");

    // Показываем игровое поле игрока (включая корабли).
    drawGrid(PLAYER_GRID_OFFSET_X, PLAYER_GRID_OFFSET_Y, true);

    // Координата X для текстовых подсказок справа от сетки.
    const int infoX = PLAYER_GRID_OFFSET_X + GRID_SIZE * CELL_SIZE + 20;
    const int lineHeight = 25; // Расстояние между строками текста.
    int currentY = 100; // Текущая вертикальная позиция текста.

    // Если есть доступные корабли для размещения.
    if (currentShipType < 4) {
        int size = shipTypes[currentShipType].size; // Текущий размер корабля.

        // Печатаем название текущего корабля.
        char header[50];
        snprintf(header, sizeof(header), "Current: %d-decker", size);
        drawText(infoX, currentY, header);
        currentY += lineHeight;

        // Показываем, сколько кораблей доступно для размещения.
        char remaining[50];
        snprintf(remaining, sizeof(remaining), "Left: %d/%d",
            shipTypes[currentShipType].count - currentShipCount,
            shipTypes[currentShipType].count);
        drawText(infoX, currentY, remaining);
        currentY += lineHeight;

        // Подсказываем, как поворачивать корабли ("R").
        drawText(infoX, currentY, "Press R to rotate");
        currentY += lineHeight * 2;

        // Отображаем предпросмотр текущего корабля.
        glColor4f(0.0, 1.0, 0.0, 0.5);
        glBegin(GL_QUADS);
        for (int i = 0; i < size; i++) {
            float px = infoX + (horizontal ? i : 0) * CELL_SIZE;
            float py = currentY + (horizontal ? 0 : i) * CELL_SIZE;

            glVertex2f(px, py);
            glVertex2f(px + CELL_SIZE, py);
            glVertex2f(px + CELL_SIZE, py + CELL_SIZE);
            glVertex2f(px, py + CELL_SIZE);
        }
        glEnd();

        currentY += (horizontal ? CELL_SIZE : size * CELL_SIZE) + lineHeight;
    }

    // Если в процессе размещения произошла ошибка, выводим сообщение.
    if (showError) {
        glColor3f(1.0, 0.0, 0.0);
        drawText(infoX, currentY, "Invalid position!");
    }

    // Обновляем экран с новой информацией.
    glutSwapBuffers();
}


/*
Функция renderGame отвечает за отрисовку процесса игры.
Она отображает игровое поле игрока и противника, состояние кораблей и текущую информацию о ходе.
*/
void renderGame() {
    // Очищаем экран перед началом обновления.
    glClear(GL_COLOR_BUFFER_BIT);

    // Отображаем заголовок "Your field" над полем игрока.
    drawText(PLAYER_GRID_OFFSET_X + (GRID_SIZE * CELL_SIZE) / 2 - 50, 50, "Your field");
    drawGrid(PLAYER_GRID_OFFSET_X, PLAYER_GRID_OFFSET_Y, true); // Поле игрока с отображением кораблей.

    // Отображаем заголовок "Enemy field" над полем противника.
    drawText(BOT_GRID_OFFSET_X + (GRID_SIZE * CELL_SIZE) / 2 - 50, 50, "Enemy field");
    drawGrid(BOT_GRID_OFFSET_X, BOT_GRID_OFFSET_Y, false); // Поле противника, без отображения его кораблей.

    drawShipCounts(); // Отображаем количество оставшихся кораблей у игрока и противника.

    glColor3f(0.0, 0.0, 0.0); // Чёрный цвет для текста хода.

    // Сообщение игроку, чей сейчас ход.
    if (playerTurn) {
        drawText(WINDOW_WIDTH / 2 - 150, WINDOW_HEIGHT - 30, "Your turn - click on enemy field");
    }
    else {
        drawText(WINDOW_WIDTH / 2 - 150, WINDOW_HEIGHT - 30, "Enemy's turn - please wait...");
    }

    glutSwapBuffers(); // Обновляем изображение на экране.
}

/*
Функция renderGameOver отвечает за отрисовку финального экрана игры.
В зависимости от результата (победа или поражение), выводится соответствующее сообщение.
Также отображаются два мини-поля: игрока и противника.
*/
void renderGameOver() {
    glClear(GL_COLOR_BUFFER_BIT); // Очищаем экран для отображения финального экрана.

    bool playerWon = checkVictory(botGrid); // Проверяем, победил ли игрок (все корабли противника уничтожены).
    const int verticalOffset = 120; // Используем вертикальный отступ для центровки текста.

    glColor3f(0.1, 0.1, 0.5); // Устанавливаем цвет заголовка.
    if (playerWon) {
        drawText(WINDOW_WIDTH / 2 - 100, WINDOW_HEIGHT / 2 - verticalOffset, "YOU WIN!");
    }
    else {
        drawText(WINDOW_WIDTH / 2 - 100, WINDOW_HEIGHT / 2 - verticalOffset, "YOU LOSE!");
    }

    glColor3f(0.0, 0.0, 0.0); // Чёрный цвет для подсказок.
    drawText(WINDOW_WIDTH / 2 - 150, WINDOW_HEIGHT / 2 + 50 - verticalOffset, "Press 'N' for new game");
    drawText(WINDOW_WIDTH / 2 - 150, WINDOW_HEIGHT / 2 + 100 - verticalOffset, "Press 'Q' to quit");

    const int miniCellSize = 20; // Размер клеток для мини-полей.
    const int fieldSpacing = 250; // Расстояние между мини-полями.
    const int startY = WINDOW_HEIGHT / 2 + 130 - verticalOffset; // Начальная координата Y для мини-полей.

    // Заголовок и отрисовка мини-поля игрока.
    drawText(PLAYER_GRID_OFFSET_X + (GRID_SIZE * miniCellSize) / 2 - 50, startY - 25, "Your field");
    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            float x = PLAYER_GRID_OFFSET_X + i * miniCellSize;
            float y = startY + j * miniCellSize;

            // Устанавливаем цвет клетки в зависимости от её состояния (корабль, попадание, промах).
            if (playerGrid[i][j].is_miss && playerGrid[i][j].is_ship) {
                glColor3f(1.0, 0.0, 0.0); // Красный (уничтоженный корабль).
            }
            else if (playerGrid[i][j].is_hit) {
                glColor3f(1.0, 0.5, 0.0); // Оранжевый (попадание).
            }
            else if (playerGrid[i][j].is_ship) {
                glColor3f(0.3, 0.3, 0.3); // Тёмно-серый (оставшийся корабль).
            }
            else {
                glColor3f(0.8, 0.8, 1.0); // Синий (пустая клетка).
            }

            // Рисуем квадрат клетки.
            glBegin(GL_QUADS);
            glVertex2f(x, y);
            glVertex2f(x + miniCellSize, y);
            glVertex2f(x + miniCellSize, y + miniCellSize);
            glVertex2f(x, y + miniCellSize);
            glEnd();
        }
    }

    // Заголовок и отрисовка мини-поля противника.
    drawText(BOT_GRID_OFFSET_X + fieldSpacing + (GRID_SIZE * miniCellSize) / 2 - 50, startY - 25, "Enemy field");
    for (int i = 0; i < GRID_SIZE; i++) {
        for (int j = 0; j < GRID_SIZE; j++) {
            float x = BOT_GRID_OFFSET_X + fieldSpacing + i * miniCellSize;
            float y = startY + j * miniCellSize;

            // Устанавливаем цвет клетки в зависимости от её состояния.
            if (botGrid[i][j].is_miss && botGrid[i][j].is_ship) {
                glColor3f(1.0, 0.0, 0.0);
            }
            else if (botGrid[i][j].is_hit) {
                glColor3f(1.0, 0.5, 0.0);
            }
            else if (botGrid[i][j].is_ship && playerWon) {
                glColor3f(0.3, 0.3, 0.3);
            }
            else {
                glColor3f(0.8, 0.8, 1.0);
            }

            glBegin(GL_QUADS);
            glVertex2f(x, y);
            glVertex2f(x + miniCellSize, y);
            glVertex2f(x + miniCellSize, y + miniCellSize);
            glVertex2f(x, y + miniCellSize);
            glEnd();
        }
    }

    glutSwapBuffers(); // Отображаем финальный экран.
}


/*
Функция display является центральной функцией отрисовки.
Она переключается между различными графическими состояниями игры (меню, расстановка, игра, завершение), вызывая соответствующие функции отрисовки.
*/
void display() {
    switch (gameState) {
    case MENU_SCREEN:
        renderMenu(); // Переход в меню игры.
        break;
    case PLACEMENT_SCREEN:
        renderPlacement(); // Этап размещения кораблей.
        break;
    case GAME_SCREEN:
        renderGame(); // Основной этап игры.
        break;
    case GAME_OVER_SCREEN:
        renderGameOver(); // Итоговый экран завершения игры.
        break;
    }
}

/*
Функция handleMouse обрабатывает пользовательский ввод с мыши.
Она интерпретирует клики для размещения кораблей или для выстрелов по вражескому полю.
*/
void handleMouse(int button, int state, int x, int y) {
    // Если игра завершена, нажатия мыши игнорируются.
    if (state != GLUT_DOWN || gameOver) return;

    // Обработка кликов во время расстановки кораблей.
    if (gameState == PLACEMENT_SCREEN && button == GLUT_LEFT_BUTTON) {
        // Преобразуем координаты клика в сетку игрового поля.
        int gridX = (x - PLAYER_GRID_OFFSET_X) / CELL_SIZE;
        int gridY = (y - PLAYER_GRID_OFFSET_Y) / CELL_SIZE;

        // Проверяем, попал ли клик внутрь игрового поля.
        if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE) {
            placeShip(gridX, gridY); // Размещаем корабль в указанной клетке.
        }
    }
    // Обработка кликов во время основного этапа игры.
    else if (gameState == GAME_SCREEN && button == GLUT_LEFT_BUTTON && playerTurn) {
        // Преобразуем координаты клика в сетку вражеского поля.
        int gridX = (x - BOT_GRID_OFFSET_X) / CELL_SIZE;
        int gridY = (y - BOT_GRID_OFFSET_Y) / CELL_SIZE;

        // Проверяем, попал ли клик внутрь вражеского игрового поля, и не стреляли ли туда ранее.
        if (gridX >= 0 && gridX < GRID_SIZE && gridY >= 0 && gridY < GRID_SIZE &&
            !botGrid[gridX][gridY].is_hit) {

            botGrid[gridX][gridY].is_hit = true; // Помечаем клетку как атакованную.

            // Если был корабль, проверяем его состояние (уничтожен или нет).
            if (botGrid[gridX][gridY].is_ship) {
                checkDestroyedShips(botGrid, gridX, gridY);

                // Проверяем, победил ли игрок (все корабли противника подбиты).
                if (checkVictory(botGrid)) {
                    gameOver = true;
                    gameState = GAME_OVER_SCREEN;
                }
                else {
                    playerTurn = true; // Сохраняем ход за игроком.
                }
            }
            else {
                playerTurn = false; // Передаём ход противнику.
                glutTimerFunc(1000, (void (*)(int))botTurn, 0); // Запускаем таймер хода бота.
            }

            glutPostRedisplay(); // Обновляем экран после выстрела.
        }
    }
}

/*
Функция handleKeyPress обрабатывает события нажатий клавиш.
Она переключает состояния игры, позволяет начать новую игру и поворачивать корабли.
*/
void handleKeyPress(unsigned char key, int x, int y) {
    switch (key) {
    case 'r': case 'R':
        // Клавиша "R" меняет ориентацию корабля (горизонтальная/вертикальная).
        if (gameState == PLACEMENT_SCREEN) {
            horizontal = !horizontal; // Переключаем ориентацию.
            glutPostRedisplay(); // Обновляем экран с предпросмотром корабля.
        }
        break;
    case 'n': case 'N':
        startNewGame(); // Начинаем новую игру.
        break;
    case 'q': case 'Q':
        exit(0); // Завершаем игру.
        break;
    default:
        // Если игра в меню, любое нажатие клавиши начинает новую игру.
        if (gameState == MENU_SCREEN) {
            startNewGame();
        }
        break;
    }
}

/*
    объявление функции для рекурсивного поиска всех частей корабля
    */
void findShipParts(Cell grid[GRID_SIZE][GRID_SIZE], int cx, int cy, bool visited[GRID_SIZE][GRID_SIZE], int shipCells[][2], int* count_ptr) {
    /*
    если координаты (cx, cy) выходят за границы поиска
    ИЛИ клетка уже посещена
    ИЛИ в ней нет корабля (!is_ship),
    то выходит из рекурсии
    */
    if (cx < 0 || cx >= GRID_SIZE || cy < 0 || cy >= GRID_SIZE || visited[cx][cy] || !grid[cx][cy].is_ship)
    {
        return;
    }

    /*
    помечает клетку как посещённую
    */
    visited[cx][cy] = true;

    /*
    записывает координаты клетки в массив shipCells

    увеличивает счётчик count
    */
    shipCells[*count_ptr][0] = cx;
    shipCells[*count_ptr][1] = cy;
    (*count_ptr)++;


    /*
    рекурсивно проверяет 4 соседние клетки
    (вверх, вниз, влево, вправо)
    */
    findShipParts(grid, cx + 1, cy, visited, shipCells, count_ptr);
    findShipParts(grid, cx - 1, cy, visited, shipCells, count_ptr);
    findShipParts(grid, cx, cy + 1, visited, shipCells, count_ptr);
    findShipParts(grid, cx, cy - 1, visited, shipCells, count_ptr);
}