# Подробная документация проекта MAPKART

## Общее описание проекта

MAPKART - это программа для раскраски карт с использованием алгоритма 4-цветной теоремы. Программа читает BMP-изображение карты, находит регионы (белые области), строит граф смежности между соседними регионами и раскрашивает их так, чтобы любые два соседних региона имели разные цвета, используя максимум 4 цвета.

---

## Структура файлов проекта

### 1. `main.c` - Главный файл программы

**Назначение:** Точка входа в программу, координирует выполнение всех этапов обработки изображения.

**Основные функции:**

#### `int main(int argc, char* argv[])`
- **Параметры:**
  - `argc` - количество аргументов командной строки
  - `argv` - массив аргументов командной строки
- **Возвращает:** 0 при успехе, 1 при ошибке
- **Описание:** 
  - Проверяет количество аргументов (должно быть 2: входной и выходной файлы)
  - Инициализирует систему логирования
  - Выполняет последовательность этапов:
    1. Чтение BMP файла
    2. Поиск регионов на изображении
    3. Построение графа смежности
    4. Раскраска графа (4 цвета)
    5. Применение цветов к изображению
    6. Запись результата в файл
  - Выводит статистику выполнения (время, количество цветов)
  - Освобождает всю выделенную память

**Зависимости:** Использует все модули проекта (bmp_handler, region_detector, graph, colorizer, utils)

---

### 2. `bmp_handler.h` и `bmp_handler.c` - Работа с BMP файлами

**Назначение:** Модуль для чтения и записи BMP-изображений формата 24-бит.

#### Структуры данных:

##### `Pixel`
```c
typedef struct {
    uint8_t b;  // Синий канал (0-255)
    uint8_t g;  // Зеленый канал (0-255)
    uint8_t r;  // Красный канал (0-255)
} Pixel;
```
- **Назначение:** Представляет один пиксель изображения в формате RGB
- **Порядок байтов:** BGR (стандарт для BMP)

##### `BMPHeader`
```c
typedef struct {
    uint16_t type;        // Тип файла (должно быть 0x4D42 = "BM")
    uint32_t size;        // Размер файла в байтах
    uint16_t reserved1;   // Зарезервировано
    uint16_t reserved2;   // Зарезервировано
    uint32_t offset;      // Смещение до начала данных изображения
} BMPHeader;
```
- **Назначение:** Заголовок BMP файла, содержит метаданные о файле

##### `BMPInfoHeader`
```c
typedef struct {
    uint32_t size;              // Размер структуры
    int32_t width;              // Ширина изображения в пикселях
    int32_t height;             // Высота изображения в пикселях
    uint16_t planes;            // Количество плоскостей (обычно 1)
    uint16_t bit_count;         // Бит на пиксель (24 для нашего случая)
    uint32_t compression;       // Тип сжатия (0 = без сжатия)
    uint32_t size_image;        // Размер данных изображения
    int32_t x_pels_per_meter;   // Горизонтальное разрешение
    int32_t y_pels_per_meter;   // Вертикальное разрешение
    uint32_t clr_used;          // Количество используемых цветов
    uint32_t clr_important;     // Количество важных цветов
} BMPInfoHeader;
```
- **Назначение:** Информационный заголовок с параметрами изображения

##### `BMPImage`
```c
typedef struct {
    BMPHeader header;           // Заголовок файла
    BMPInfoHeader info_header;  // Информационный заголовок
    Pixel* data;                // Массив пикселей (width * height элементов)
} BMPImage;
```
- **Назначение:** Полная структура для хранения BMP изображения в памяти

#### Функции:

##### `BMPImage* read_bmp(const char* filename)`
- **Параметры:**
  - `filename` - путь к входному BMP файлу
- **Возвращает:** Указатель на структуру BMPImage или NULL при ошибке
- **Описание:**
  - Открывает файл в бинарном режиме для чтения
  - Читает заголовки BMP файла
  - Проверяет корректность формата (тип "BM", 24 бита на пиксель)
  - Выделяет память для массива пикселей
  - Читает данные изображения построчно с учетом выравнивания (padding)
  - BMP файлы имеют выравнивание строк по 4 байта, поэтому добавляется padding
  - Возвращает полностью загруженное изображение в памяти
- **Обработка ошибок:** Возвращает NULL при ошибках открытия файла, неверном формате или нехватке памяти

##### `int write_bmp(const char* filename, BMPImage* image)`
- **Параметры:**
  - `filename` - путь к выходному BMP файлу
  - `image` - указатель на структуру BMPImage для записи
- **Возвращает:** 1 при успехе, 0 при ошибке
- **Описание:**
  - Открывает файл в бинарном режиме для записи
  - Записывает заголовки BMP файла
  - Записывает данные изображения построчно с учетом выравнивания
  - Добавляет padding байты для выравнивания строк
  - Сохраняет обработанное изображение на диск
- **Обработка ошибок:** Возвращает 0 при ошибках открытия файла или записи

##### `void free_bmp(BMPImage* image)`
- **Параметры:**
  - `image` - указатель на структуру BMPImage для освобождения
- **Описание:**
  - Освобождает память, выделенную для массива пикселей
  - Освобождает память самой структуры BMPImage
  - Предотвращает утечки памяти
- **Важно:** Всегда вызывать после использования изображения

---

### 3. `region_detector.h` и `region_detector.c` - Поиск регионов на изображении

**Назначение:** Модуль для обнаружения и нумерации связных белых областей (регионов) на изображении.

#### Функции:

##### `int is_white(Pixel p)`
- **Параметры:**
  - `p` - структура Pixel для проверки
- **Возвращает:** 1 если пиксель белый, 0 иначе
- **Описание:**
  - Проверяет, является ли пиксель белым
  - Условие: все каналы (R, G, B) должны быть больше 250
  - Используется для определения, какие пиксели принадлежат регионам (белые) и какие являются границами (черные)
- **Логика:** Пиксель считается белым, если он очень светлый (почти максимальная яркость)

##### `void flood_fill(int x, int y, int width, int height, Pixel* data, int* region_map, int current_region_id)`
- **Параметры:**
  - `x, y` - координаты начальной точки для заливки
  - `width, height` - размеры изображения
  - `data` - массив пикселей изображения
  - `region_map` - массив для хранения номеров регионов (размер width * height)
  - `current_region_id` - номер региона, которым нужно заполнить область
- **Описание:**
  - Рекурсивная функция заливки (flood fill) для поиска связных областей
  - Алгоритм:
    1. Проверяет границы массива (выход за пределы)
    2. Проверяет, не обработан ли уже этот пиксель (region_map[index] != 0)
    3. Проверяет, является ли пиксель белым
    4. Если все условия выполнены, помечает пиксель номером региона
    5. Рекурсивно вызывает себя для 4 соседних пикселей (вверх, вниз, влево, вправо)
  - Использует 4-связность (только горизонтальные и вертикальные соседи)
  - Помечает все пиксели одного связного белого региона одинаковым номером
- **Особенности:** Рекурсивная реализация может вызвать переполнение стека на очень больших изображениях

##### `int* find_regions(BMPImage* image, int* region_count)`
- **Параметры:**
  - `image` - указатель на структуру BMPImage
  - `region_count` - указатель на переменную для сохранения количества найденных регионов
- **Возвращает:** Указатель на массив region_map или NULL при ошибке
- **Описание:**
  - Главная функция модуля для поиска всех регионов на изображении
  - Алгоритм:
    1. Выделяет память для region_map (массив размером width * height)
    2. Инициализирует region_map нулями (0 = граница/не обработано)
    3. Проходит по всем пикселям изображения
    4. Для каждого необработанного белого пикселя:
       - Присваивает новый номер региона (начиная с 1)
       - Вызывает flood_fill для заливки всей связной области этим номером
       - Увеличивает счетчик регионов
    5. Выводит прогресс обработки (процент)
    6. Сохраняет общее количество найденных регионов
  - **Результат:** Массив region_map, где:
    - `region_map[i] = 0` означает границу или необработанный пиксель
    - `region_map[i] > 0` означает номер региона (1, 2, 3, ...)
  - Каждый связный белый регион получает уникальный номер
- **Память:** Выделяет память, которую нужно освободить после использования

---

### 4. `graph.h` и `graph.c` - Работа с графом смежности

**Назначение:** Модуль для создания и управления графом смежности регионов. Граф представляет связи между соседними регионами на карте.

#### Структуры данных:

##### `Graph`
```c
typedef struct {
    int** matrix;        // Матрица смежности (двумерный массив)
    int num_vertices;    // Количество вершин (регионов + 1, т.к. индексация с 0)
} Graph;
```
- **Назначение:** Представляет граф в виде матрицы смежности
- **Матрица смежности:** 
  - `matrix[i][j] = 1` означает, что регионы i и j соседние
  - `matrix[i][j] = 0` означает, что регионы не соседние
  - Матрица симметрична (неориентированный граф)

#### Функции:

##### `Graph* create_graph(int num_vertices)`
- **Параметры:**
  - `num_vertices` - количество вершин графа
- **Возвращает:** Указатель на созданный граф или NULL при ошибке
- **Описание:**
  - Выделяет память для структуры Graph
  - Выделяет память для массива указателей (строки матрицы)
  - Выделяет память для каждой строки матрицы
  - Инициализирует все элементы матрицы нулями (calloc)
  - Создает пустой граф без рёбер
- **Память:** Выделяет память, которую нужно освободить через free_graph()

##### `void free_graph(Graph* graph)`
- **Параметры:**
  - `graph` - указатель на граф для освобождения
- **Описание:**
  - Освобождает память каждой строки матрицы
  - Освобождает память массива указателей
  - Освобождает память структуры Graph
  - Предотвращает утечки памяти
- **Важно:** Всегда вызывать после использования графа

##### `void add_edge(Graph* graph, int v1, int v2)`
- **Параметры:**
  - `graph` - указатель на граф
  - `v1, v2` - номера вершин (регионов) для соединения
- **Описание:**
  - Добавляет ребро между вершинами v1 и v2
  - Проверяет, что v1 != v2 (не добавляет петли)
  - Устанавливает matrix[v1][v2] = 1 и matrix[v2][v1] = 1 (симметричная матрица)
  - Создает неориентированное ребро (связь работает в обе стороны)
- **Использование:** Вызывается при обнаружении соседних регионов

##### `Graph* build_adjacency_graph(int* region_map, int width, int height, int num_regions)`
- **Параметры:**
  - `region_map` - массив с номерами регионов для каждого пикселя
  - `width, height` - размеры изображения
  - `num_regions` - количество найденных регионов
- **Возвращает:** Указатель на построенный граф
- **Описание:**
  - **Главная функция модуля** - строит граф смежности регионов
  - **Алгоритм состоит из двух этапов:**
  
  **Этап 1: Прямые касания**
  - Проходит по всем пикселям изображения
  - Для каждого пикселя региона (region_id > 0):
    - Проверяет 4 соседних пикселя (вверх, вниз, влево, вправо)
    - Если соседний пиксель принадлежит другому региону:
      - Добавляет ребро между этими регионами
      - Логирует добавление ребра
  
  **Этап 2: Регионы через границы**
  - Проходит по всем пикселям границ (region_id = 0)
  - Для каждого пикселя границы:
    - Проверяет 4 направления и собирает уникальные регионы вокруг границы
    - Если вокруг одной границы найдены разные регионы:
      - Добавляет рёбра между всеми парами этих регионов
      - Это позволяет находить соседние регионы, даже если они разделены границами
  
  - **Оптимизации:**
    - Использует индуктивные переменные (предвычисление y_offset)
    - Развертка цикла для 4 направлений
    - Проверка на дубликаты рёбер перед добавлением
  - **Результат:** Граф, где вершины - регионы, рёбра - связи между соседними регионами
- **Логирование:** Записывает в лог все добавленные рёбра и статистику

---

### 5. `colorizer.h` и `colorizer.c` - Раскраска графа

**Назначение:** Модуль для раскраски графа регионов с использованием алгоритма Welsh-Powell и ограничением в 4 цвета.

#### Структуры данных:

##### `VertexDegree`
```c
typedef struct {
    int vertex;   // Номер вершины (региона)
    int degree;   // Степень вершины (количество соседей)
} VertexDegree;
```
- **Назначение:** Вспомогательная структура для сортировки вершин по степени

#### Функции логирования:

##### `void init_logging(const char* log_filename)`
- **Параметры:**
  - `log_filename` - имя файла для логирования
- **Описание:**
  - Открывает файл для записи логов
  - Записывает заголовок с временем начала работы
  - Инициализирует глобальную переменную log_file
- **Использование:** Вызывается в начале main()

##### `void close_logging()`
- **Описание:**
  - Записывает время окончания работы
  - Закрывает файл логов
  - Очищает глобальную переменную log_file
- **Использование:** Вызывается в конце main()

##### `void log_message(const char* format, ...)`
- **Параметры:**
  - `format` - строка формата (как в printf)
  - `...` - переменное количество аргументов
- **Описание:**
  - Записывает форматированное сообщение в лог-файл
  - Использует va_list для обработки переменных аргументов
  - Немедленно сбрасывает буфер (fflush) для сохранения данных
- **Использование:** Используется во всех модулях для логирования

#### Вспомогательные функции раскраски:

##### `static inline int get_degree(Graph* graph, int vertex)`
- **Параметры:**
  - `graph` - указатель на граф
  - `vertex` - номер вершины
- **Возвращает:** Степень вершины (количество соседей)
- **Описание:**
  - Вычисляет степень вершины (количество рёбер, исходящих из вершины)
  - Подсчитывает количество единиц в строке матрицы смежности
  - **Оптимизации:**
    - Развертка цикла (обработка по 4 элемента за итерацию)
    - Снижение мощности (один раз получает указатель на строку)
    - Inline функция для устранения накладных расходов
- **Использование:** Вызывается для каждой вершины перед сортировкой

##### `static inline int is_color_safe(Graph* graph, int vertex, int color, int* result_colors)`
- **Параметры:**
  - `graph` - указатель на граф
  - `vertex` - номер вершины для проверки
  - `color` - цвет для проверки
  - `result_colors` - массив уже назначенных цветов
- **Возвращает:** 1 если цвет безопасен, 0 если есть конфликт
- **Описание:**
  - Проверяет, можно ли назначить данный цвет вершине
  - Условие безопасности: ни один сосед вершины не должен иметь этот цвет
  - **Алгоритм:**
    1. Проходит по всем соседям вершины (проверяет строку матрицы)
    2. Если сосед имеет ребро (matrix[vertex][i] == 1) и уже раскрашен в проверяемый цвет:
       - Возвращает 0 (цвет небезопасен)
    3. Если конфликтов не найдено, возвращает 1 (цвет безопасен)
  - **Оптимизации:**
    - Ранний выход при первом конфликте
    - Развертка цикла для ускорения
    - Inline функция
- **Использование:** Вызывается для каждого цвета перед назначением

##### `static int compare_vertex_degree(const void* a, const void* b)`
- **Параметры:**
  - `a, b` - указатели на структуры VertexDegree для сравнения
- **Возвращает:** Отрицательное число если a < b, положительное если a > b, 0 если равны
- **Описание:**
  - Функция сравнения для qsort
  - Сравнивает вершины по степени в порядке убывания
  - Используется для сортировки вершин перед раскраской
- **Использование:** Передается в qsort()

#### Основные функции раскраски:

##### `int* color_graph(Graph* graph, int* num_colors)`
- **Параметры:**
  - `graph` - указатель на граф для раскраски
  - `num_colors` - указатель на переменную для сохранения количества использованных цветов
- **Возвращает:** Массив цветов для каждой вершины (индекс = номер региона)
- **Описание:**
  - **Главная функция модуля** - реализует алгоритм Welsh-Powell для раскраски графа
  - **Алгоритм Welsh-Powell:**
  
  **Шаг 1: Инициализация**
  - Выделяет память для массива result_colors
  - Инициализирует все цвета нулями (не раскрашено)
  
  **Шаг 2: Вычисление степеней**
  - Для каждой вершины вычисляет степень (количество соседей)
  - Сохраняет степени в массив degrees
  - Логирует степени всех вершин
  
  **Шаг 3: Сортировка вершин**
  - Создает массив структур VertexDegree
  - Сортирует вершины по убыванию степени с помощью qsort
  - Это гарантирует, что вершины с большим количеством соседей раскрашиваются первыми
  - **Оптимизация:** Использует qsort (O(V log V)) вместо bubble sort (O(V²))
  
  **Шаг 4: Раскраска вершин**
  - Проходит по отсортированным вершинам
  - Для каждой вершины:
    - Пробует цвета от 1 до 4 (MAX_COLORS = 4)
    - Для каждого цвета проверяет безопасность (is_color_safe)
    - Назначает первый безопасный цвет
    - Обновляет максимальный использованный цвет
  - **Оптимизация:** Развертка цикла для 4 цветов (явная проверка каждого)
  
  **Шаг 5: Результат**
  - Сохраняет количество использованных цветов
  - Возвращает массив цветов для каждого региона
  - Логирует финальную раскраску
  
  - **Гарантии:** Алгоритм гарантирует, что соседние регионы получат разные цвета
  - **Ограничение:** Используется максимум 4 цвета (теорема о 4 красках)
- **Память:** Выделяет память, которую нужно освободить после использования

##### `void apply_colors_to_image(BMPImage* image, int* region_map, int* colors)`
- **Параметры:**
  - `image` - указатель на изображение для раскраски
  - `region_map` - массив номеров регионов для каждого пикселя
  - `colors` - массив цветов для каждого региона (индекс = номер региона)
- **Описание:**
  - Применяет цвета к изображению на основе раскраски графа
  - **Алгоритм:**
    1. Определяет палитру из 4 цветов:
       - Цвет 0: Черный (границы)
       - Цвет 1: Красный (255, 0, 0)
       - Цвет 2: Зеленый (0, 255, 0)
       - Цвет 3: Синий (0, 0, 255)
       - Цвет 4: Желтый (255, 255, 0)
    2. Проходит по всем пикселям изображения:
       - Если пиксель принадлежит региону (region_id > 0):
         - Получает цвет региона из массива colors
         - Применяет соответствующий цвет из палитры
       - Если пиксель - граница (region_id = 0):
         - Оставляет черным
    3. Подсчитывает статистику (количество цветных и граничных пикселей)
  - **Оптимизации:**
    - Развертка цикла (обработка по 4 пикселя за итерацию)
    - Предвычисление total_pixels и black_pixel
    - Тернарный оператор для упрощения условий
  - **Результат:** Изображение с раскрашенными регионами
- **Логирование:** Записывает статистику применения цветов

---

### 6. `utils.h` и `utils.c` - Вспомогательные утилиты

**Назначение:** Модуль для измерения времени выполнения программы.

#### Структуры данных:

##### `Timer`
```c
typedef struct {
    clock_t start;  // Время начала измерения
    clock_t end;    // Время окончания измерения
} Timer;
```
- **Назначение:** Хранит временные метки для измерения длительности операции

#### Функции:

##### `void start_timer(Timer* timer)`
- **Параметры:**
  - `timer` - указатель на структуру Timer
- **Описание:**
  - Записывает текущее время в поле start
  - Использует clock() для получения времени процессора
  - Начинает измерение времени выполнения

##### `void stop_timer(Timer* timer)`
- **Параметры:**
  - `timer` - указатель на структуру Timer
- **Описание:**
  - Записывает текущее время в поле end
  - Завершает измерение времени выполнения

##### `double get_duration(Timer* timer)`
- **Параметры:**
  - `timer` - указатель на структуру Timer
- **Возвращает:** Длительность в секундах (double)
- **Описание:**
  - Вычисляет разницу между end и start
  - Преобразует в секунды делением на CLOCKS_PER_SEC
  - Возвращает время выполнения операции
- **Использование:** Вызывается после stop_timer() для получения результата

---

## Поток выполнения программы

### Последовательность работы:

1. **Инициализация** (`main.c`)
   - Проверка аргументов командной строки
   - Инициализация логирования

2. **Чтение изображения** (`bmp_handler.c`)
   - Открытие BMP файла
   - Чтение заголовков
   - Загрузка пикселей в память

3. **Поиск регионов** (`region_detector.c`)
   - Проход по всем пикселям
   - Flood fill для каждого белого региона
   - Создание region_map

4. **Построение графа** (`graph.c`)
   - Создание графа
   - Поиск прямых касаний регионов
   - Поиск регионов через границы
   - Построение матрицы смежности

5. **Раскраска графа** (`colorizer.c`)
   - Вычисление степеней вершин
   - Сортировка по убыванию степени
   - Раскраска алгоритмом Welsh-Powell
   - Назначение цветов регионам

6. **Применение цветов** (`colorizer.c`)
   - Проход по всем пикселям
   - Применение цветов из палитры
   - Сохранение границ черными

7. **Запись результата** (`bmp_handler.c`)
   - Запись заголовков
   - Запись пикселей с учетом padding
   - Сохранение файла

8. **Завершение** (`main.c`)
   - Освобождение памяти
   - Закрытие логов
   - Вывод статистики

---

## Алгоритмы и оптимизации

### Алгоритм поиска регионов:
- **Метод:** Flood Fill (заливка)
- **Сложность:** O(W × H) где W×H - размер изображения
- **Особенности:** Рекурсивная реализация, 4-связность

### Алгоритм построения графа:
- **Метод:** Двухпроходный поиск соседей
- **Сложность:** O(W × H × 4) - проверка 4 направлений для каждого пикселя
- **Оптимизации:**
  - Индуктивные переменные (предвычисление индексов)
  - Развертка цикла для 4 направлений
  - Проверка дубликатов рёбер

### Алгоритм раскраски:
- **Метод:** Welsh-Powell (жадный алгоритм с сортировкой)
- **Сложность:** O(V log V + V × E × C) где:
  - V - количество вершин (регионов)
  - E - среднее количество рёбер на вершину
  - C - количество цветов (4)
- **Оптимизации:**
  - qsort вместо bubble sort (O(V log V) вместо O(V²))
  - Развертка цикла для проверки цветов
  - Ранний выход при проверке безопасности
  - Inline функции для снижения накладных расходов

### Оптимизации применения цветов:
- **Метод:** Развертка цикла
- **Сложность:** O(W × H)
- **Оптимизации:**
  - Обработка по 4 пикселя за итерацию
  - Предвычисление констант

---

## Формат данных

### region_map:
- **Тип:** `int*` (массив целых чисел)
- **Размер:** `width * height`
- **Значения:**
  - `0` - граница или необработанный пиксель
  - `> 0` - номер региона (1, 2, 3, ...)

### colors:
- **Тип:** `int*` (массив целых чисел)
- **Размер:** `num_vertices` (количество регионов + 1)
- **Значения:**
  - `0` - не используется
  - `1-4` - номер цвета (1=Красный, 2=Зеленый, 3=Синий, 4=Желтый)

### Граф смежности:
- **Тип:** `int**` (двумерный массив)
- **Размер:** `num_vertices × num_vertices`
- **Значения:**
  - `0` - регионы не соседние
  - `1` - регионы соседние

---

## Обработка ошибок

### Проверки в программе:
1. **Аргументы командной строки:** Проверка количества
2. **Открытие файлов:** Проверка успешности fopen()
3. **Формат BMP:** Проверка типа файла и битности
4. **Выделение памяти:** Проверка возвращаемых значений malloc/calloc
5. **Границы массивов:** Проверка индексов перед доступом

### Возвращаемые значения:
- Функции возвращают NULL или 0 при ошибках
- main() возвращает 1 при ошибках, 0 при успехе

---

## Зависимости между модулями

```
main.c
  ├── bmp_handler.h (чтение/запись изображений)
  ├── region_detector.h (поиск регионов)
  │   └── bmp_handler.h (использует Pixel, BMPImage)
  ├── graph.h (построение графа)
  │   └── colorizer.h (для логирования)
  ├── colorizer.h (раскраска)
  │   ├── graph.h (использует Graph)
  │   └── bmp_handler.h (использует BMPImage, Pixel)
  └── utils.h (измерение времени)
```

---

## Пример использования

```bash
./map_colorizer input.bmp output.bmp
```

**Входные данные:**
- BMP файл с черно-белой картой
- Белые области = регионы
- Черные пиксели = границы

**Выходные данные:**
- BMP файл с раскрашенной картой
- 4 цвета для регионов
- Черные границы сохранены
- Лог-файл с подробной информацией

---

## Примечания

1. **Формат BMP:** Поддерживается только 24-битный формат без сжатия
2. **Размер изображения:** Ограничен доступной памятью
3. **Рекурсия:** Flood fill может вызвать переполнение стека на очень больших изображениях
4. **Цвета:** Используется максимум 4 цвета согласно теореме о 4 красках
5. **Логирование:** Создается подробный лог всех операций в файле `map_coloring_log_<output>.txt`

---

*Документация создана: 2025*
*Версия проекта: 1.0*

